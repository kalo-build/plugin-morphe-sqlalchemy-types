package compile

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// MorpheWriter handles writing compiled output to files in the target format
type MorpheWriter struct {
	OutputPath string
	// Configuration with sensible defaults
	FileExtension      string
	UseMultiFile       bool // Default: true (one file per type)
	CreateIndexFile    bool // Default: true (create index that imports all)
	IndentSize         int  // Default: 2 or 4 depending on format
	AddGeneratedHeader bool // Default: true
}

// NewMorpheWriter creates a new MorpheWriter instance with sensible defaults
func NewMorpheWriter(outputPath string) *MorpheWriter {
	return &MorpheWriter{
		OutputPath:         outputPath,
		FileExtension:      ".py",
		UseMultiFile:       true,
		CreateIndexFile:    true,
		IndentSize:         4,
		AddGeneratedHeader: true,
	}
}

// getGeneratedHeader returns a header comment for generated files
func (w *MorpheWriter) getGeneratedHeader() string {
	return `# Code generated by Morphe
# Source: Morphe Registry

`
}

// ensureDir creates a directory if it doesn't exist
func (w *MorpheWriter) ensureDir(dir string) error {
	return os.MkdirAll(dir, 0755)
}

// writeFile writes content to a file with optional header
func (w *MorpheWriter) writeFile(path string, content []byte) error {
	// Add generated header if enabled
	if w.AddGeneratedHeader {
		header := []byte(w.getGeneratedHeader())
		content = append(header, content...)
	}

	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := w.ensureDir(dir); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	return os.WriteFile(path, content, 0644)
}

// WriteEnum writes a single enum definition to a file
func (w *MorpheWriter) WriteEnum(enumName string, content []byte) error {
	fileName := toFileName(enumName) + w.FileExtension
	filePath := filepath.Join(w.OutputPath, "enums", fileName)
	return w.writeFile(filePath, content)
}

// WriteModel writes a single model definition to a file
func (w *MorpheWriter) WriteModel(modelName string, content []byte) error {
	fileName := toFileName(modelName) + w.FileExtension
	filePath := filepath.Join(w.OutputPath, "models", fileName)
	return w.writeFile(filePath, content)
}

// WriteStructure writes a single structure definition to a file
func (w *MorpheWriter) WriteStructure(structureName string, content []byte) error {
	fileName := toFileName(structureName) + w.FileExtension
	filePath := filepath.Join(w.OutputPath, "structures", fileName)
	return w.writeFile(filePath, content)
}

// WriteEntity writes a single entity definition to a file
func (w *MorpheWriter) WriteEntity(entityName string, content []byte) error {
	fileName := toFileName(entityName) + w.FileExtension
	filePath := filepath.Join(w.OutputPath, "entities", fileName)
	return w.writeFile(filePath, content)
}

// WriteAllEnums writes multiple enum definitions
func (w *MorpheWriter) WriteAllEnums(enumContents map[string][]byte) error {
	if w.UseMultiFile {
		// Write each enum to a separate file
		for enumName, content := range enumContents {
			if err := w.WriteEnum(enumName, content); err != nil {
				return err
			}
		}

		// Create index file if enabled
		if w.CreateIndexFile {
			return w.writeEnumIndex(enumContents)
		}
		return nil
	}

	// Single file mode
	return w.writeSingleFile("enums", enumContents)
}

// WriteAllModels writes multiple model definitions
func (w *MorpheWriter) WriteAllModels(modelContents map[string][]byte) error {
	if w.UseMultiFile {
		for modelName, content := range modelContents {
			if err := w.WriteModel(modelName, content); err != nil {
				return err
			}
		}

		if w.CreateIndexFile {
			return w.writeModelIndex(modelContents)
		}
		return nil
	}

	return w.writeSingleFile("models", modelContents)
}

// WriteAllStructures writes multiple structure definitions
func (w *MorpheWriter) WriteAllStructures(structureContents map[string][]byte) error {
	if w.UseMultiFile {
		for structureName, content := range structureContents {
			if err := w.WriteStructure(structureName, content); err != nil {
				return err
			}
		}

		if w.CreateIndexFile {
			return w.writeStructureIndex(structureContents)
		}
		return nil
	}

	return w.writeSingleFile("structures", structureContents)
}

// WriteAllEntities writes multiple entity definitions
func (w *MorpheWriter) WriteAllEntities(entityContents map[string][]byte) error {
	if w.UseMultiFile {
		for entityName, content := range entityContents {
			if err := w.WriteEntity(entityName, content); err != nil {
				return err
			}
		}

		if w.CreateIndexFile {
			return w.writeEntityIndex(entityContents)
		}
		return nil
	}

	return w.writeSingleFile("entities", entityContents)
}

// Index file generators - creates a file that imports/exports all types
func (w *MorpheWriter) writeEnumIndex(contents map[string][]byte) error {
	// Python __init__.py file
	var imports []string
	for enumName := range contents {
		fileName := toFileName(enumName)
		imports = append(imports, fmt.Sprintf("from .%s import %s", fileName, enumName))
	}

	sort.Strings(imports)
	content := []byte(strings.Join(imports, "\n"))
	content = append(content, '\n')

	filePath := filepath.Join(w.OutputPath, "enums", "__init__.py")
	return w.writeFile(filePath, content)
}

func (w *MorpheWriter) writeModelIndex(contents map[string][]byte) error {
	var imports []string
	for modelName := range contents {
		fileName := toFileName(modelName)
		imports = append(imports, fmt.Sprintf("from .%s import %s", fileName, modelName))
	}

	sort.Strings(imports)
	content := []byte(strings.Join(imports, "\n"))
	content = append(content, '\n')

	filePath := filepath.Join(w.OutputPath, "models", "__init__.py")
	return w.writeFile(filePath, content)
}

func (w *MorpheWriter) writeStructureIndex(contents map[string][]byte) error {
	var imports []string
	for structureName := range contents {
		fileName := toFileName(structureName)
		imports = append(imports, fmt.Sprintf("from .%s import %s", fileName, structureName))
	}

	sort.Strings(imports)
	content := []byte(strings.Join(imports, "\n"))
	content = append(content, '\n')

	filePath := filepath.Join(w.OutputPath, "structures", "__init__.py")
	return w.writeFile(filePath, content)
}

func (w *MorpheWriter) writeEntityIndex(contents map[string][]byte) error {
	var imports []string
	for entityName := range contents {
		fileName := toFileName(entityName)
		imports = append(imports, fmt.Sprintf("from .%s import %s", fileName, entityName))
	}

	sort.Strings(imports)
	content := []byte(strings.Join(imports, "\n"))
	content = append(content, '\n')

	filePath := filepath.Join(w.OutputPath, "entities", "__init__.py")
	return w.writeFile(filePath, content)
}

// writeSingleFile writes all content of a type to a single file
func (w *MorpheWriter) writeSingleFile(typeName string, contents map[string][]byte) error {
	var combined []byte

	// Add file header
	if w.AddGeneratedHeader {
		combined = append(combined, []byte(w.getGeneratedHeader())...)
	}

	// Combine all contents
	for name, content := range contents {
		combined = append(combined, []byte(fmt.Sprintf("\n// --- %s ---\n", name))...)
		combined = append(combined, content...)
		combined = append(combined, '\n')
	}

	// Write to single file
	fileName := typeName + w.FileExtension
	filePath := filepath.Join(w.OutputPath, fileName)
	return os.WriteFile(filePath, combined, 0644)
}

// WriteBaseFile writes the base.py file that defines the declarative base
func (w *MorpheWriter) WriteBaseFile() error {
	content := []byte(`# Code generated by Morphe
# SQLAlchemy Base definition

from sqlalchemy.ext.declarative import declarative_base

# Create the declarative base that all models will inherit from
Base = declarative_base()

# You can customize the Base class here if needed
# For example:
# Base.query = db.session.query_property()
`)

	filePath := filepath.Join(w.OutputPath, "base.py")
	// Don't add the header since content already has it
	return os.WriteFile(filePath, content, 0644)
}

// Helper function to convert type names to file names
func toFileName(typeName string) string {
	// TODO: Adjust for your format's file naming conventions
	// Examples:
	// - PascalCase → snake_case for Python
	// - PascalCase → kebab-case for some formats
	// - Keep PascalCase for C#/Java

	// Default: convert to lowercase with underscores
	var result []rune
	for i, r := range typeName {
		if i > 0 && 'A' <= r && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}
